/**
 * This is a model used with Mongoose to give structure to database entries within collections.
 * It is formatted to be a website user, and has all the basics needed for logging in and signing up.
 */

const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const validator = require('validator');

const Schema = mongoose.Schema;

/**
 * Represents a user
 * 
 * _id: Not shown, auto generated by mongoose when added to collection
 * email: The user's email
 * password: The user's password
 * userName: A public name for the user displayed for author credits
 * snapshot: A user bio.
 * totalSaves: Total times a user's lists have been saved
 * totalPos: Total positive favor of a user's list.
 * totalLists: Total number of lists created and active.
 * eventListWIP: A save of the last list a user was working on that was not submitted using this format.
 * eventListInteractions: Contains objects for each list the user has interacted with
 *                        using this format:
 *                        {
 *                          _id: List's Mongoose id
 *                          saved: Boolean showing if list is saved
 *                          favor: 1 for like, -1 for dislike, 0 for neither
 *                        }
 */
const userSchema = new Schema({
    
    email: {
        type: String,
        required: true,
        unique: true //Can only be one email of this name in the whole collection
    },
    password: {
        type: String,
        required: true
    },
    userName: {
        type: String,
        required: true,
        unique: true
    },
    eventListWip: {},
    eventListInteractions: {
        type: [{}]
    },
    snapshot: String,
    totalSaves: {
        required: true,
        type: Number
    },
    totalPos: {
        required: true,
        type: Number
    },
    totalLists: {
        required: true,
        type: Number
    }
}, {timestamps:true})

// Static Signup Method that can be accessed when this schema is in use (User.Signup(...))
// Can't be an arrow function since it's static
userSchema.statics.signup = async function(email, password, userName) {

    // Validation using imported validator instead of endless regexs
    if (!email || !password || !userName) {
        throw Error('All fields must be filled');
    }
    if (!validator.isEmail(email)) {
        throw Error('Email is not valid');
    }
    if (!validator.isStrongPassword(password)) {
        //This place holder is for formatting purposes, replaced in the frontend.
        throw Error('Password placeholder');
    }

    //Checks that this User exists by email
    const emailExists = await this.findOne({ email });

    if (emailExists) {
        throw Error('Email already in use');
    }

    //Checks that this User exists by userName
    const userNameExists = await this.findOne({ userName });

    if (userNameExists) {
        throw Error('User name is already taken');
    }

    // Generates 10 "salt" characters to be added to the end of the password
    const salt = await bcrypt.genSalt(10);

    // Encodes the password+salt through an algorithm into an encrypted string
    const hash = await bcrypt.hash(password, salt);

    const user = await this.create({ email, password: hash, userName, totalPos: 0, totalSaves: 0, totalLists: 0 });

    return user;
}

// Static Login Method that can be accessed when this schema is in use (User.Signup(...))
// Can't be an arrow function since it's static
userSchema.statics.login = async function(email, password) {

    // Validation
    if (!email || !password) {
        throw Error('All fields must be filled');
    }

    // Checks that user exists
    const user = await this.findOne({ email });

    if (!user) {
        throw Error('Incorrect email');
    }

    // Compares the given password to the hashed password of the retrieved user
    const match = await bcrypt.compare(password, user.password);

    if (!match) {
        throw Error('Incorrect password');
    }

    return user;
}

// Static getter for a WIPList
userSchema.statics.getWIPList = async function(email) {

    // Validation
    if (!email) {
        throw Error('No email given');
    }

    // Checks that user exists
    const user = await this.findOne({ email });

    if (!user) {
        throw Error('Incorrect email');
    }

    const WIPList = user.eventListWip;

    
    return WIPList;
}

// Static getter to return all user information displayed on profile page.
userSchema.statics.getUserProfile = async function(userName) {
    // Validation
    if (!userName) {
        throw Error('No userName given');
    }

    // Checks that user exists
    const user = await this.findOne({ userName });

    if (!user) {
        throw Error('Incorrect userName');
    }

    let joinDate = new Date(user.createdAt);

    const profile = {userName: user.userName, snapshot: user.snapshot, totalPos: user.totalPos, totalSaves: user.totalSaves, joined: joinDate.toLocaleDateString(), totalLists: user.totalLists}

    return profile;
}

userSchema.statics.getSavedEventLists = async function(email) {
    
    // Validation
    if (!email) {
        throw Error('No email given');
    }

    // Checks that user exists
    const user = await this.findOne({ email });

    if (!user) {
        throw Error('Incorrect email');
    }

    let findIDs = [];

    for (let i = 0; i < user.eventListInteractions.length; i++)
    {
        if (user.eventListInteractions[i]["saved"] === true)
        {
            findIDs.push(user.eventListInteractions[i]._id)
        }
    }

    const response = await fetch('http://localhost:4000/api/eventLists/matches', {
        method: 'POST',  
        body: JSON.stringify(findIDs),        
        headers: {
                        'Content-Type': 'application/json',
                    }
                });
    
    return await response.json();
}

module.exports = mongoose.model('User', userSchema);

//Â© 2025 Daxton Sutherland <daxtonass77@gmail.com>, all rights reserved.